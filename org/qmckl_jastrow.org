#+TITLE: Jastrow Factor
#+SETUPFILE: ../tools/theme.setup
#+INCLUDE: ../tools/lib.org

Functions for the calculation of the Jastrow factor \(f_{ee}, f_{en}, f_{een}\).
These are stored in the ~factor_ee~, ~factor_en~, and ~factor_een~ variables.
The ~jastrow~ structure contains all the information required to build
these factors along with their derivatives.

* Headers                                                          :noexport:
  #+begin_src elisp :noexport :results none
(org-babel-lob-ingest "../tools/lib.org")
#+end_src


  #+begin_src c :tangle (eval h_private_type)
#ifndef QMCKL_JASTROW_HPT
#define QMCKL_JASTROW_HPT
#include <stdbool.h>
  #+end_src

  #+begin_src c :tangle (eval c_test) :noweb yes
#include "qmckl.h"
#include <assert.h>
#include <math.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "chbrclf.h"

int main() {
  qmckl_context context;
  context = qmckl_context_create();
  #+end_src

  #+begin_src c :tangle (eval c)
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#elif HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>

#include <stdio.h>

#include "qmckl.h"
#include "qmckl_context_private_type.h"
#include "qmckl_memory_private_type.h"
#include "qmckl_memory_private_func.h"
#include "qmckl_jastrow_private_func.h"
#include "qmckl_jastrow_private_type.h"
  #+end_src


* Context
   :PROPERTIES:
   :Name:     qmckl_jastrow
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

  The following data stored in the context:

   #+NAME: qmckl_jastrow_args
  |------------+-------------------------------------------+-----+-------------------------------------------------------------------|
  | ~int32_t~  | ~uninitialized~                           | in  | Keeps bit set for uninitialized data                              |
  | ~int64_t~  | ~aord_num~                                | in  | The number of a coeffecients                                      |
  | ~int64_t~  | ~bord_num~                                | in  | The number of b coeffecients                                      |
  | ~int64_t~  | ~cord_num~                                | in  | The number of c coeffecients                                      |
  | ~uint64_t~ | ~type_nuc_num~                            | in  | Number of Nucleii types                                           |
  | ~double~   | ~aord_vector[aord_num + 1][type_nuc_num]~ | in  | Order of a polynomial coefficients                                |
  | ~double~   | ~bord_vector[bord_num + 1]~               | in  | Order of b polynomial coefficients                                |
  | ~double~   | ~cord_vector[cord_num][type_nuc_num]~     | in  | Order of c polynomial coefficients                                |
  | ~double~   | ~factor_ee~                               | out | Jastrow factor: electron-electron part                            |
  | ~double~   | ~factor_en~                               | out | Jastrow factor: electron-nucleus  part                            |
  | ~double~   | ~factor_een~                              | out | Jastrow factor: electron-electron-nucleus  part                   |
  | ~double~   | ~factor_ee_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_en_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_een_deriv_e[4][nelec]~            | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |

  computed data:

  |-------------------+--------------------------------------------+-------------------------------------------------|
  | ~uint64_t~        | ~dim_cord_vec~                             | Number of unique C coefficients                 |
  | ~coord_vect_full~ | ~[dim_cord_vec][nuc_num]~                  | vector of non-zero coefficients                 |
  | ~lkpm_of_cindex~  | ~[4][dim_cord_vec]~                        | Transform l,k,p, and m into consecutive indices |
  | ~tmp_c~           | ~[elec_num][nuc_num][ncord + 1][ncord]~    | vector of non-zero coefficients                 |
  | ~dtmp_c~          | ~[elec_num][4][nuc_num][ncord + 1][ncord]~ | vector of non-zero coefficients                 |

  For H2O we have the following data:

   #+BEGIN_EXAMPLE
type_nuc_num = 1
aord_num     = 5
bord_num     = 5
cord_num     = 23
dim_cord_vec = 23

aord_vector = [ 0.000000000000000E+000,  0.000000000000000E+000, -0.380512000000000E+000,
 -0.157996000000000E+000, -3.155800000000000E-002,  2.151200000000000E-002]

bord_vector = [ 0.500000000000000E-000,  0.153660000000000E-000,  6.722620000000000E-002,
  2.157000000000000E-002,  7.309600000000000E-003,  2.866000000000000E-003]

cord_vector = [ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ]

cord_vector_full = [
[ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ],
[ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ],
]

lkpm_of_cindex = 
         [ 1, 1, 2, 0, 0, 0, 2, 1, 1, 2, 3, 0, 2, 1, 3, 0, 0, 1,
           3, 1, 1, 0, 3, 1, 1, 3, 4, 0, 2, 2, 4, 0, 0, 2, 4, 1,
           3, 1, 4, 0, 1, 1, 4, 1, 2, 0, 4, 1, 0, 0, 4, 2, 1, 4,
           5, 0, 2, 3, 5, 0, 0, 3, 5, 1, 3, 2, 5, 0, 1, 2, 5, 1,
           4, 1, 5, 0, 2, 1, 5, 1, 0, 1, 5, 2, 3, 0, 5, 1, 1, 0,
           5, 2 ]


   #+END_EXAMPLE



** Data structure

   #+begin_src c :comments org :tangle (eval h_private_type)
typedef struct qmckl_jastrow_struct{
  int32_t uninitialized;
  int64_t aord_num;
  int64_t bord_num;
  int64_t cord_num;
  uint64_t type_nuc_num;
  double * aord_vector;
  double * bord_vector;
  double * cord_vector;
  double * factor_ee;
  double * factor_en;
  double * factor_een;
  double * factor_ee_deriv_e;
  double * factor_en_deriv_e;
  double * factor_een_deriv_e;
  uint64_t dim_cord_vec;
  double * coord_vect_full;
  double * tmp_c;
  double * dtmp_c;
  bool      provided;
  char      type;
} qmckl_jastrow_struct;
    #+end_src


   The ~uninitialized~ integer contains one bit set to one for each
   initialization function which has not been called. It becomes equal
   to zero after all initialization functions have been called. The
   struct is then initialized and ~provided == true~.
   Some values are initialized by default, and are not concerned by
   this mechanism.

   #+begin_src c :comments org :tangle (eval h_private_func) 
qmckl_exit_code qmckl_init_jastrow(qmckl_context context);
   #+end_src
   
   #+begin_src c :comments org :tangle (eval c)
qmckl_exit_code qmckl_init_jastrow(qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  ctx->jastrow.uninitialized = (1 << 4) - 1;

  /* Default values */

  return QMCKL_SUCCESS;
}
   #+end_src
   
   
      #+begin_src c :comments org :tangle (eval h_func)
bool qmckl_jastrow_provided (const qmckl_context context);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
bool qmckl_jastrow_provided(const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  return ctx->jastrow.provided;
}
      #+end_src



* End of files                                                     :noexport:

  #+begin_src c :tangle (eval h_private_type)
#endif
  #+end_src

*** Test
  #+begin_src c :tangle (eval c_test)
    qmckl_exit_code rc = qmckl_context_destroy(context);
    assert (rc == QMCKL_SUCCESS);

    return 0;
}
  #+end_src


# -*- mode: org -*-
# vim: syntax=c



