#+TITLE: Jastrow Factor
#+SETUPFILE: ../tools/theme.setup
#+INCLUDE: ../tools/lib.org

Functions for the calculation of the Jastrow factor \(f_{ee}, f_{en}, f_{een}\).
These are stored in the ~factor_ee~, ~factor_en~, and ~factor_een~ variables.
The ~jastrow~ structure contains all the information required to build
these factors along with their derivatives.

* Headers                                                          :noexport:
  #+begin_src elisp :noexport :results none
(org-babel-lob-ingest "../tools/lib.org")
#+end_src


  #+begin_src c :tangle (eval h_private_type)
#ifndef QMCKL_JASTROW_HPT
#define QMCKL_JASTROW_HPT
#include <stdbool.h>
  #+end_src

  #+begin_src c :tangle (eval c_test) :noweb yes
#include "qmckl.h"
#include <assert.h>
#include <math.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "chbrclf.h"

int main() {
  qmckl_context context;
  context = qmckl_context_create();
  #+end_src

  #+begin_src c :tangle (eval c)
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#elif HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>

#include <stdio.h>

#include "qmckl.h"
#include "qmckl_context_private_type.h"
#include "qmckl_memory_private_type.h"
#include "qmckl_memory_private_func.h"
#include "qmckl_jastrow_private_func.h"
#include "qmckl_jastrow_private_type.h"
  #+end_src

* Context
   :PROPERTIES:
   :Name:     qmckl_jastrow
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

  The following data stored in the context:

   #+NAME: qmckl_jastrow_args
  |------------+-------------------------------------------+-----+-------------------------------------------------------------------|
  | ~int32_t~  | ~uninitialized~                           | in  | Keeps bit set for uninitialized data                              |
  | ~int64_t~  | ~aord_num~                                | in  | The number of a coeffecients                                      |
  | ~int64_t~  | ~bord_num~                                | in  | The number of b coeffecients                                      |
  | ~int64_t~  | ~cord_num~                                | in  | The number of c coeffecients                                      |
  | ~uint64_t~ | ~type_nuc_num~                            | in  | Number of Nucleii types                                           |
  | ~double~   | ~aord_vector[aord_num + 1][type_nuc_num]~ | in  | Order of a polynomial coefficients                                |
  | ~double~   | ~bord_vector[bord_num + 1]~               | in  | Order of b polynomial coefficients                                |
  | ~double~   | ~cord_vector[cord_num][type_nuc_num]~     | in  | Order of c polynomial coefficients                                |
  | ~double~   | ~factor_ee~                               | out | Jastrow factor: electron-electron part                            |
  | ~double~   | ~factor_en~                               | out | Jastrow factor: electron-nucleus  part                            |
  | ~double~   | ~factor_een~                              | out | Jastrow factor: electron-electron-nucleus  part                   |
  | ~double~   | ~factor_ee_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_en_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_een_deriv_e[4][nelec]~            | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |

  computed data:

  |-------------------+--------------------------------------------+-------------------------------------------------|
  | ~uint64_t~        | ~dim_cord_vec~                             | Number of unique C coefficients                 |
  | ~coord_vect_full~ | ~[dim_cord_vec][nuc_num]~                  | vector of non-zero coefficients                 |
  | ~lkpm_of_cindex~  | ~[4][dim_cord_vec]~                        | Transform l,k,p, and m into consecutive indices |
  | ~tmp_c~           | ~[elec_num][nuc_num][ncord + 1][ncord]~    | vector of non-zero coefficients                 |
  | ~dtmp_c~          | ~[elec_num][4][nuc_num][ncord + 1][ncord]~ | vector of non-zero coefficients                 |

  For H2O we have the following data:

   #+BEGIN_EXAMPLE
type_nuc_num = 1
aord_num     = 5
bord_num     = 5
cord_num     = 23
dim_cord_vec = 23
aord_vector = [ 0.000000000000000E+000,  0.000000000000000E+000, -0.380512000000000E+000,
 -0.157996000000000E+000, -3.155800000000000E-002,  2.151200000000000E-002]
bord_vector = [ 0.500000000000000E-000,  0.153660000000000E-000,  6.722620000000000E-002,
  2.157000000000000E-002,  7.309600000000000E-003,  2.866000000000000E-003]
cord_vector = [ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ]
cord_vector_full = [
[ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ],
[ 0.571702000000000E-000, -0.514253000000000E-000, -0.513043000000000E-000, 
  9.486000000000000E-003, -4.205000000000000E-003,  0.426325800000000E-000,
  8.288150000000000E-002,  5.118600000000000E-003, -2.997800000000000E-003,
 -5.270400000000000E-003, -7.499999999999999E-005, -8.301649999999999E-002,
  1.454340000000000E-002,  5.143510000000000E-002,  9.250000000000000E-004,
 -4.099100000000000E-003,  4.327600000000000E-003, -1.654470000000000E-003,
  2.614000000000000E-003, -1.477000000000000E-003, -1.137000000000000E-003,
 -4.010475000000000E-002,  6.106710000000000E-003 ],
]
lkpm_of_cindex = 
         [ 1, 1, 2, 0, 0, 0, 2, 1, 1, 2, 3, 0, 2, 1, 3, 0, 0, 1,
           3, 1, 1, 0, 3, 1, 1, 3, 4, 0, 2, 2, 4, 0, 0, 2, 4, 1,
           3, 1, 4, 0, 1, 1, 4, 1, 2, 0, 4, 1, 0, 0, 4, 2, 1, 4,
           5, 0, 2, 3, 5, 0, 0, 3, 5, 1, 3, 2, 5, 0, 1, 2, 5, 1,
           4, 1, 5, 0, 2, 1, 5, 1, 0, 1, 5, 2, 3, 0, 5, 1, 1, 0,
           5, 2 ]
   #+END_EXAMPLE



** Data structure

   #+begin_src c :comments org :tangle (eval h_private_type)
typedef struct qmckl_jastrow_struct{
  int32_t  uninitialized;
  int64_t  aord_num;
  int64_t  bord_num;
  int64_t  cord_num;
  int64_t  type_nuc_num;
  double * aord_vector;
  double * bord_vector;
  double * cord_vector;
  double * factor_ee;
  double * factor_en;
  double * factor_een;
  double * factor_ee_deriv_e;
  double * factor_en_deriv_e;
  double * factor_een_deriv_e;
  int64_t  dim_cord_vec;
  double * coord_vect_full;
  double * tmp_c;
  double * dtmp_c;
  bool     provided;
  char     type;
} qmckl_jastrow_struct;
    #+end_src


   The ~uninitialized~ integer contains one bit set to one for each
   initialization function which has not been called. It becomes equal
   to zero after all initialization functions have been called. The
   struct is then initialized and ~provided == true~.
   Some values are initialized by default, and are not concerned by
   this mechanism.

   #+begin_src c :comments org :tangle (eval h_private_func) 
qmckl_exit_code qmckl_init_jastrow(qmckl_context context);
   #+end_src
   
   #+begin_src c :comments org :tangle (eval c)
qmckl_exit_code qmckl_init_jastrow(qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  ctx->jastrow.uninitialized = (1 << 5) - 1;

  /* Default values */

  return QMCKL_SUCCESS;
}
   #+end_src
   
   
      #+begin_src c :comments org :tangle (eval h_func)
bool qmckl_jastrow_provided (const qmckl_context context);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
bool qmckl_jastrow_provided(const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  return ctx->jastrow.provided;
}
      #+end_src


** Access functions

   #+begin_src c :comments org :tangle (eval h_private_func) :exports none
int64_t  qmckl_get_jastrow_aord_num       (qmckl_context context);
int64_t  qmckl_get_jastrow_bord_num       (qmckl_context context);
int64_t  qmckl_get_jastrow_cord_num       (qmckl_context context);
int64_t  qmckl_get_jastrow_type_nuc_num   (qmckl_context context);
double*  qmckl_get_jastrow_aord_vector    (qmckl_context context);
double*  qmckl_get_jastrow_bord_vector    (qmckl_context context);
double*  qmckl_get_jastrow_cord_vector    (qmckl_context context);
   #+end_src

   When all the data for the AOs have been provided, the following
   function returns ~true~.

   #+begin_src c :comments org :tangle (eval h_func)
bool      qmckl_jastrow_provided           (const qmckl_context context);
   #+end_src

   #+NAME:post
   #+begin_src c :exports none
if ( (ctx->jastrow.uninitialized & mask) != 0) {
  return NULL;
}
   #+end_src

   #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
int64_t qmckl_get_jastrow_aord_num (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 0;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.aord_num > 0);
  return ctx->jastrow.aord_num;
}

int64_t qmckl_get_jastrow_bord_num (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 1;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.bord_num > 0);
  return ctx->jastrow.bord_num;
}

int64_t qmckl_get_jastrow_cord_num (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 0;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.cord_num > 0);
  return ctx->jastrow.cord_num;
}

int64_t qmckl_get_type_nuc_num (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 2;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.type_nuc_num > 0);
  return ctx->jastrow.type_nuc_num;
}

double* qmckl_get_aord_vector (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 3;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.aord_vector != NULL);
  return ctx->jastrow.aord_vector;
}

double* qmckl_get_bord_vector (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 3;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.bord_vector != NULL);
  return ctx->jastrow.bord_vector;
}

double* qmckl_get_cord_vector (const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return (char) 0;
  }
  
  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  int32_t mask = 1 << 3;

  if ( (ctx->jastrow.uninitialized & mask) != 0) {
    return (char) 0;
  }

  assert (ctx->jastrow.cord_vector != NULL);
  return ctx->jastrow.cord_vector;
}
   #+end_src

** Initialization functions

   To prepare for the Jastrow and its derivative, all the following functions need to be
   called.

   #+begin_src c :comments org :tangle (eval h_func)
qmckl_exit_code  qmckl_set_jastrow_ord_num       (qmckl_context context, const int64_t aord_num, const int64_t bord_num, const int64_t cord_num);
qmckl_exit_code  qmckl_set_jastrow_type_nuc_num  (qmckl_context context, const int64_t type_nuc_num);
qmckl_exit_code  qmckl_set_jastrow_aord_vector   (qmckl_context context, const double * aord_vector);
qmckl_exit_code  qmckl_set_jastrow_bord_vector   (qmckl_context context, const double * bord_vector);
qmckl_exit_code  qmckl_set_jastrow_cord_vector   (qmckl_context context, const double * cord_vector);
   #+end_src

   #+NAME:pre2
   #+begin_src c  :exports none
if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
  return QMCKL_NULL_CONTEXT;
 }

qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
   #+end_src

   #+NAME:post2
   #+begin_src c  :exports none
ctx->jastrow.uninitialized &= ~mask;
ctx->jastrow.provided = (ctx->jastrow.uninitialized == 0);
if (ctx->jastrow.provided) {
  qmckl_exit_code rc_ = qmckl_finalize_basis(context);
  if (rc_ != QMCKL_SUCCESS) return rc_;
 }

return QMCKL_SUCCESS;
   #+end_src


   #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
qmckl_exit_code qmckl_set_jastrow_ord_num(qmckl_context context, const int64_t aord_num, const int64_t bord_num, const int64_t cord_num) {
<<pre2>>

  if (aord_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_ord_num",
                           "aord_num <= 0");
  }

  if (bord_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_ord_num",
                           "bord_num <= 0");
  }

  if (cord_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_ord_num",
                           "cord_num <= 0");
  }

  int32_t mask = 1 << 1;
  ctx->jastrow.aord_num = aord_num;
  ctx->jastrow.bord_num = bord_num;
  ctx->jastrow.cord_num = cord_num;

  <<post2>>
}

qmckl_exit_code qmckl_set_jastrow_type_nuc_num(qmckl_context context, const int64_t type_nuc_num) {
<<pre2>>

  if (type_nuc_num <= 0) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_type_nuc_num",
                           "type_nuc_num < 0");
  }

  int32_t mask = 1 << 2;
  ctx->jastrow.type_nuc_num = type_nuc_num;

  <<post2>>
}

qmckl_exit_code qmckl_set_jastrow_aord_vector(qmckl_context context, double const * aord_vector) {
<<pre2>>

  int32_t mask = 1 << 3;

  const int64_t aord_num = qmckl_get_jastrow_aord_num(context);
  if (aord_num == 0) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_jastrow_coefficient",
                           "aord_num is not set");
  }

  if (aord_vector == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_aord_vector",
                           "aord_vector = NULL");
  }
  
  if (ctx->jastrow.aord_vector != NULL) {
    qmckl_exit_code rc = qmckl_free(context, ctx->jastrow.aord_vector);
    if (rc != QMCKL_SUCCESS) {
      return qmckl_failwith( context, rc,
                             "qmckl_set_ord_vector",
                             NULL);
    }
  }

  qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  mem_info.size = aord_num * sizeof(double);
  double* new_array = (double*) qmckl_malloc(context, mem_info);

  if(new_array == NULL) {
    return qmckl_failwith( context,
                           QMCKL_ALLOCATION_FAILED,
                           "qmckl_set_jastrow_coefficient",
                           NULL);
  }

  memcpy(new_array, aord_vector, mem_info.size);

  ctx->jastrow.aord_vector = new_array;

  <<post2>>
}

qmckl_exit_code qmckl_set_jastrow_bord_vector(qmckl_context context, double const * bord_vector) {
<<pre2>>

  int32_t mask = 1 << 4;

  const int64_t bord_num = qmckl_get_jastrow_bord_num(context);
  if (bord_num == 0) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_jastrow_coefficient",
                           "bord_num is not set");
  }

  if (bord_vector == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_bord_vector",
                           "bord_vector = NULL");
  }
  
  if (ctx->jastrow.bord_vector != NULL) {
    qmckl_exit_code rc = qmckl_free(context, ctx->jastrow.bord_vector);
    if (rc != QMCKL_SUCCESS) {
      return qmckl_failwith( context, rc,
                             "qmckl_set_ord_vector",
                             NULL);
    }
  }

  qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  mem_info.size = bord_num * sizeof(double);
  double* new_array = (double*) qmckl_malloc(context, mem_info);

  if(new_array == NULL) {
    return qmckl_failwith( context,
                           QMCKL_ALLOCATION_FAILED,
                           "qmckl_set_jastrow_coefficient",
                           NULL);
  }

  memcpy(new_array, bord_vector, mem_info.size);

  ctx->jastrow.aord_vector = new_array;

  <<post2>>
}

qmckl_exit_code qmckl_set_jastrow_cord_vector(qmckl_context context, double const * cord_vector) {
<<pre2>>

  int32_t mask = 1 << 5;

  const int64_t cord_num = qmckl_get_jastrow_cord_num(context);
  if (cord_num == 0) {
    return qmckl_failwith( context,
                           QMCKL_FAILURE,
                           "qmckl_set_jastrow_coefficient",
                           "cord_num is not set");
  }

  if (cord_vector == NULL) {
    return qmckl_failwith( context,
                           QMCKL_INVALID_ARG_2,
                           "qmckl_set_jastrow_cord_vector",
                           "cord_vector = NULL");
  }
  
  if (ctx->jastrow.cord_vector != NULL) {
    qmckl_exit_code rc = qmckl_free(context, ctx->jastrow.cord_vector);
    if (rc != QMCKL_SUCCESS) {
      return qmckl_failwith( context, rc,
                             "qmckl_set_ord_vector",
                             NULL);
    }
  }

  qmckl_memory_info_struct mem_info = qmckl_memory_info_struct_zero;
  mem_info.size = cord_num * sizeof(double);
  double* new_array = (double*) qmckl_malloc(context, mem_info);

  if(new_array == NULL) {
    return qmckl_failwith( context,
                           QMCKL_ALLOCATION_FAILED,
                           "qmckl_set_jastrow_coefficient",
                           NULL);
  }

  memcpy(new_array, cord_vector, mem_info.size);

  ctx->jastrow.cord_vector = new_array;

  <<post2>>
}
   #+end_src


* End of files                                                     :noexport:

  #+begin_src c :tangle (eval h_private_type)
#endif
  #+end_src

*** Test
  #+begin_src c :tangle (eval c_test)
    qmckl_exit_code rc = qmckl_context_destroy(context);
    assert (rc == QMCKL_SUCCESS);

    return 0;
}
  #+end_src


# -*- mode: org -*-
# vim: syntax=c



