#+TITLE: Jastrow Factor
#+SETUPFILE: ../tools/theme.setup
#+INCLUDE: ../tools/lib.org

Functions for the calculation of the Jastrow factor \(f_{ee}, f_{en}, f_{een}\).
These are stored in the ~factor_ee~, ~factor_en~, and ~factor_een~ variables.
The ~jastrow~ structure contains all the information required to build
these factors along with their derivatives.

* Headers                                                          :noexport:
  #+begin_src elisp :noexport :results none
(org-babel-lob-ingest "../tools/lib.org")
#+end_src


  #+begin_src c :tangle (eval h_private_type)
#ifndef QMCKL_JASTROW_HPT
#define QMCKL_JASTROW_HPT
#include <stdbool.h>
  #+end_src

  #+begin_src c :tangle (eval c_test) :noweb yes
#include "qmckl.h"
#include <assert.h>
#include <math.h>
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "chbrclf.h"

int main() {
  qmckl_context context;
  context = qmckl_context_create();
  #+end_src

  #+begin_src c :tangle (eval c)
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
#elif HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>

#include <stdio.h>

#include "qmckl.h"
#include "qmckl_context_private_type.h"
#include "qmckl_memory_private_type.h"
#include "qmckl_memory_private_func.h"
#include "qmckl_jastrow_private_func.h"
  #+end_src


* Context
   :PROPERTIES:
   :Name:     qmckl_jastrow
   :CRetType: qmckl_exit_code
   :FRetType: qmckl_exit_code
   :END:

  The following data stored in the context:

   #+NAME: qmckl_jastrow_args
  |------------+-------------------------------------------+-----+-------------------------------------------------------------------|
  | ~int32_t~  | ~uninitialized~                           | in  | Keeps bit set for uninitialized data                              |
  | ~int64_t~  | ~aord_num~                                | in  | The number of a coeffecients                                      |
  | ~int64_t~  | ~bord_num~                                | in  | The number of b coeffecients                                      |
  | ~int64_t~  | ~cord_num~                                | in  | The number of c coeffecients                                      |
  | ~uint64_t~ | ~type_nuc_num~                            | in  | Number of Nucleii types                                           |
  | ~uint64_t~ | ~dim_cord_vec~                            | in  | Number of unique C coefficients                                   |
  | ~double~   | ~aord_vector[aord_num + 1][type_nuc_num]~ | in  | Order of a polynomial coefficients                                |
  | ~double~   | ~bord_vector[bord_num + 1]~               | in  | Order of b polynomial coefficients                                |
  | ~double~   | ~cord_vector[cord_num][type_nuc_num]~     | in  | Order of c polynomial coefficients                                |
  | ~double~   | ~factor_ee~                               | out | Jastrow factor: electron-electron part                            |
  | ~double~   | ~factor_en~                               | out | Jastrow factor: electron-nucleus  part                            |
  | ~double~   | ~factor_een~                              | out | Jastrow factor: electron-electron-nucleus  part                   |
  | ~double~   | ~factor_ee_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_en_deriv_e[4][nelec]~             | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |
  | ~double~   | ~factor_een_deriv_e[4][nelec]~            | out | Derivative of the Jastrow factor: electron-electron-nucleus  part |

  computed data:

  |-------------------+--------------------------------------------+---------------------------------|
  | ~coord_vect_full~ | ~[dim_cord_vec]~                           | vector of non-zero coefficients |
  | ~tmp_c~           | ~[elec_num][nuc_num][ncord + 1][ncord]~    | vector of non-zero coefficients |
  | ~dtmp_c~          | ~[elec_num][4][nuc_num][ncord + 1][ncord]~ | vector of non-zero coefficients |


** Data structure

    #+CALL: generate_c_header(table=qmckl_jastrow_args,rettyp=get_value("CRetType"),fname=get_value("Name"))

    #+RESULTS:
    #+begin_src c :tangle (eval h_func) :comments org
    qmckl_exit_code qmckl_jastrow (
	  const int32_t uninitialized,
	  const int64_t aord_num,
	  const int64_t bord_num,
	  const int64_t cord_num,
	  const uint64_t type_nuc_num,
	  const uint64_t dim_cord_vec,
	  const double* aord_vector,
	  const double* bord_vector,
	  const double* cord_vector,
	  double* const factor_ee,
	  double* const factor_en,
	  double* const factor_een,
	  double* const factor_ee_deriv_e,
	  double* const factor_en_deriv_e,
	  double* const factor_een_deriv_e ); 
    #+end_src


   The ~uninitialized~ integer contains one bit set to one for each
   initialization function which has not been called. It becomes equal
   to zero after all initialization functions have been called. The
   struct is then initialized and ~provided == true~.
   Some values are initialized by default, and are not concerned by
   this mechanism.

   #+begin_src c :comments org :tangle (eval h_private_func) 
qmckl_exit_code qmckl_init_jastrow(qmckl_context context);
   #+end_src
   
   #+begin_src c :comments org :tangle (eval c)
qmckl_exit_code qmckl_init_jastrow(qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  ctx->jastrow.uninitialized = (1 << 2) - 1;

  /* Default values */
  ctx->jastrow.rescale_factor_kappa_ee = 1.0;
  ctx->jastrow.rescale_factor_kappa_en = 1.0;

  return QMCKL_SUCCESS;
}
   #+end_src
   
   
      #+begin_src c :comments org :tangle (eval h_func)
bool qmckl_jastrow_provided (const qmckl_context context);
      #+end_src

      #+begin_src c :comments org :tangle (eval c) :noweb yes :exports none
bool qmckl_jastrow_provided(const qmckl_context context) {

  if (qmckl_context_check(context) == QMCKL_NULL_CONTEXT) {
    return false;
  }

  qmckl_context_struct* const ctx = (qmckl_context_struct* const) context;
  assert (ctx != NULL);

  return ctx->jastrow.provided;
}
      #+end_src



